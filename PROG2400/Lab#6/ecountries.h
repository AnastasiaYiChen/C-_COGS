/* C++ code produced by gperf version 3.1 */
/* Command-line: gperf -L C++ --output-file ecountries.h ECountries.txt  */
/* Computed positions: -k'2-3,5' */

#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
/* The character set is not based on ISO-646.  */
#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gperf@gnu.org>."
#endif


#define TOTAL_KEYWORDS 51
#define MIN_WORD_LENGTH 5
#define MAX_WORD_LENGTH 22
#define MIN_HASH_VALUE 6
#define MAX_HASH_VALUE 126
/* maximum key range = 121, duplicates = 0 */

class Perfect_Hash
{
private:
  static inline unsigned int hash (const char *str, size_t len);
public:
  static const char *in_word_set (const char *str, size_t len);
};

inline unsigned int
Perfect_Hash::hash (const char *str, size_t len)
{
  static unsigned char asso_values[] =
    {
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127,   0,   5,  55,
        5,   5,  60,  55,   0,  20,  15,  55,   0,  15,
       25,   0,  25,   0,   5,   5,  40,   0,   5,   5,
      127,   0,   0,   0, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127,   0, 127, 127,
      127, 127,   0, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127
    };
  return len + asso_values[static_cast<unsigned char>(str[4])] + asso_values[static_cast<unsigned char>(str[2]+1)] + asso_values[static_cast<unsigned char>(str[1])];
}

const char *
Perfect_Hash::in_word_set (const char *str, size_t len)
{
  static const char * wordlist[] =
    {
      "", "", "", "", "", "",
      "Cyprus",
      "Hungary",
      "",
      "SanMarino",
      "\357\273\277Albania",
      "Norway",
      "Denmark",
      "Portugal",
      "",
      "Montenegro",
      "Turkey",
      "Germany",
      "",
      "Macedonia",
      "Malta",
      "Netherlands",
      "Moldova",
      "Bulgaria",
      "",
      "Luxembourg",
      "Latvia",
      "Finland",
      "",
      "Lithuania",
      "",
      "Switzerland",
      "Belarus",
      "Slovakia",
      "", "",
      "Serbia",
      "Estonia",
      "Slovenia",
      "", "", "",
      "Andorra",
      "", "", "",
      "Poland",
      "Belgium",
      "", "",
      "Italy",
      "Kosovo",
      "Austria",
      "", "", "", "",
      "Romania",
      "",
      "United Kingdom",
      "Spain",
      "Monaco",
      "Armenia",
      "", "",
      "Kazakhstan",
      "Russia",
      "Vatican City",
      "", "", "",
      "France",
      "Ireland",
      "",
      "Czech Republic",
      "Azerbaijan",
      "Sweden",
      "Croatia",
      "", "", "", "",
      "Bosnia and Herzegovina",
      "", "", "", "",
      "Ukraine",
      "", "", "", "",
      "Georgia",
      "Liechtenstein",
      "", "", "", "", "", "", "", "", "",
      "", "", "", "", "", "", "", "", "",
      "", "", "", "", "", "", "", "", "",
      "",
      "Iceland",
      "", "", "",
      "Greece"
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE)
        {
          const char *s = wordlist[key];

          if (*str == *s && !strcmp (str + 1, s + 1))
            return s;
        }
    }
  return 0;
}
